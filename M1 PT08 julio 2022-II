
// 4Ô∏è‚É£ ***** EJERCICIO 4 ***** - devuelveMayores() 4Ô∏è‚É£

// Implementar la funci√≥n devuelveMayores, que recibe por par√°metro una LinkedList con precios
// de productos de una determinada g√≥ndola de Henry Market, y un precio m√°ximo a evaluar.
// La funci√≥n deber√° recorrer la LinkedList recibida y retornar la CANTIDAD DE PRECIOS QUE SUPEREN
// el valor de precio m√°ximo que se desea evaluar.
// En caso de que ning√∫n precio supere dicho valor, debe retornar en string "Sin precios"

//  EJEMPLOS:
//
//  listaPrecios1 = 5 => 10 => 8 => 7 => 14 => 20
//  devuelveMayores(listaPrecios1, 10) => 2
//  (2 precios (14 y 20) superan el valor a evaluar (10))
//
//  listaPrecios2 = 99 => 100 => 81 => 74 => 14 => 22
//  devuelveMayores(listaPrecios2, 50) => 4
//  (4 precios (99, 100, 81 y 74) superan el valor a evaluar (50))
//
//  listaPrecios3 = 99 => 80 => 81 => 75 => 15 => 21
//  devuelveMayores(listaPrecios3, 100) => "Sin precios"
//  (Ning√∫n precio de la lista supera el valor a evaluar (100))
//
//  REQUISITOS:
//    üü¢ La funci√≥n debe retornar un valor num√©rico, que representa la CANTIDAD DE PRECIOS que superen
//      el valor a evaluar.
//    üü¢ En caso de que ning√∫n precio supere dicho valor, debe retornar el string "Sin precios".
//
//  ATENCI√ìN! Las respuestas en strings son case sensitive!

function devuelveMayores(lista, valor) {
  // Tu c√≥digo aqu√≠:
  let amount = 0;
  let current = lista.head;
  while(current){
    if(current.value > valor){
      amount++;
    }
    current = current.next;
  }
  if(amount === 0) return 'Sin precios';
  
  return amount;
};

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  devuelveMayores
};
// 5Ô∏è‚É£ ***** EJERCICIO 5 ***** - cobrarClientes 5Ô∏è‚É£

// Implementar la funci√≥n cobrarClientes, que recibir√° una
// Queue (fila) de clientes que esperan para realizar el pago
// de sus compras del supermercado.
//
// Cada cliente dentro de la fila estar√° como objeto, y tendr√°
// la siguiente estructura:
//
// {
//   nombre: "Jorge",
//   dinero: 1500,
//   precioProductos: 1200
// }
//
// - nombre: Nombre del cliente
// - dinero: Dinero disponible que tiene el cliente
// - precioProductos: Suma de los productos que desea comprar
//
// La funci√≥n debe evaluar si el primer cliente de la fila poseee dinero suficiente
// para abonar los productos que desea comprar. En caso de ser as√≠, debe remover
// al cliente de la fila.
// En caso de presentarse un cliente que no posee dinero suficiente, debe dejar de
// evaluar los clientes de la fila, y retornar un array con los NOMBRES de los clientes
// que fueron correctamente retirados de la fila.
//
// EJEMPLO:
//
// clientes=[
//  {
//   nombre: "Jorge",
//   dinero: 1500,
//   precioProductos: 1200
//  },
//  {
//   nombre: "Mateo",
//   dinero: 2000,
//   precioProductos: 1900
//  },
//  {
//   nombre: "Mora",
//   dinero: 5000,
//   precioProductos: 5500
//  },
//]
//
// cobrarClientes(clientes) => ["Jorge","Mateo"]
//.
// ‚ö†Ô∏è ATENCI√ìN ‚ö†Ô∏è
// Recuerden que los "clientes" recibidos por par√°metro se encuentran
// en una Queue! Por lo cual tendremos que utilizar los m√©todos que
// tenemos implementados para esta clase.
//
// CONSIGNAS:
//  üü¢ Cuando termine de evaluar clientes, la funci√≥n debe retornar un array con los nombres de los clientes que
//    han abonado correctamente.
//  üü¢ En caso de quedarse sin clientes en la fila, la funci√≥n debe retornar false.

function cobrarClientes(clientes) {
  // Tu c√≥digo aqu√≠:
  let arrayClientes = [];
  while(clientes.size() > 0){
    if(clientes.array[0]['dinero'] > clientes.array[0]['precioProductos']){
      arrayClientes.push(clientes.array[0]['nombre']);
      clientes.dequeue();
    } else{
      return arrayClientes;
    }
  }
  return false;
};

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  cobrarClientes
};
const { BinarySearchTree } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 6Ô∏è‚É£ ***** EJERCICIO 6 ***** -- agregarProductos 6Ô∏è‚É£
// Implementar la funci√≥n agregarProductos(producto) al prototipo de BinarySearchTree, que nos servir√° para
// agregar LOS NOMBRES de los productos en una g√≥ndola de supermercado en base a las comparacionesde sus precios,
// siguiendo la siguiente tabla:
//
//    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//    ‚îÇProductos‚îÇ Precios‚îÇ
//    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
//    ‚îÇ  Leche  ‚îÇ  100   ‚îÇ
//    ‚îÇ  Queso  ‚îÇ  150   ‚îÇ
//    ‚îÇ   Pan   ‚îÇ   50   ‚îÇ
//    ‚îÇ Frutas  ‚îÇ  110   ‚îÇ
//    ‚îÇ  Arroz  ‚îÇ   40   ‚îÇ
//    ‚îÇ  Jugo   ‚îÇ   80   ‚îÇ
//    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//
//  EJEMPLO:
//
//  Si partimos del √°rbol inicial llamado "arbolDeProductos" con un solo nodo:
//
//                                              Leche
//                                              /    \
//
//    arbolDeProductos.agregarProductos(Queso)
//
//                                              Leche
//                                              /    \
//                                                   Queso
//
// El producto "Queso" se insert√≥ a la derecha, ya que su precio (150), es mayor que el precio Leche (100).
//
//    arbolDeProductos.agregarProductos(Pan)
//
//                                             Leche
//                                             /    \
//                                          Pan      Queso
//
// El producto "Pan" se insert√≥ a la izquierda, ya que su precio (50), es menor que el precio Leche (100).
//
//    arbolDeProductos.agregarProductos(Frutas)
//
//                                             Leche
//                                            /     \
//                                         Pan       Queso
//                                                  /
//                                               Frutas
//
// El producto "Frutas" en la posici√≥n correspondiente, ya que su precio (110), supera al de Leche (100) y
// es menor que precio de Queso (150).
//
// CONSIGNAS:
//  üü¢ En caso de querer insertar un producto que ya se encuentra en el √°rbol, debe retornar
//    el string "Ya existe el producto".
//  üü¢ En caso de querer insertar un producto que no se encuentra en la tabla de precios, debe retornar
//    el string "Producto inexistente".
//  üü¢ El m√©todo debe insertar el producto en la posici√≥n correspondiente, basando su ubicaci√≥n en el
//    precio del producto. (Ver ejemplos)
//  üü¢ En caso de insertar el producto correctamente, debe retornar el nuevo nodo que ha sido insertado.
//
//
// IMPORTANTE! La lista de productos se encuentra en el objeto productos a continuaci√≥n:
//‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è

//‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

BinarySearchTree.prototype.agregarProductos = function (nombreProducto, productos) {
  // Tu c√≥digo aqu√≠:
  if(!productos.hasOwnProperty(nombreProducto)){
    return 'Producto inexistente';
  }
  if(this.value === nombreProducto){
    return 'Ya existe el producto';
  } else if(productos[this.value] > productos[nombreProducto]){
    if(this.left){
      return this.left.agregarProductos(nombreProducto, productos);
    } else{
      let newTree = new BinarySearchTree(nombreProducto);
      this.left = newTree;
      return newTree;
    }
  } else{
    if(this.right){
      return this.right.agregarProductos(nombreProducto, productos);
    } else{
      let newTree = new BinarySearchTree(nombreProducto);
      this.right = newTree;
      return this.right;
    }
  }
};

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    BinarySearchTree
};
// 7Ô∏è‚É£ ***** EJERCICIO 7 ***** - ordenarPrecios() 7Ô∏è‚É£
// Implementar la funci√≥n ordenarPrecios, la cual recibir√° un array que representa una lista desordenada
// de precios de Henry Market y, a trav√©s de alguno de los m√©todos de ordenamiento vistos en el m√≥dulo (a elecci√≥n),
// deber√° retornar un array con los precios ordenados de menor a mayor.
// As√≠mismo, en caso de que la funci√≥n se encuentre con alg√∫n precio 0 (cero) dentro del array, debe desestimar
// el ordenamiento, y retornar false.
//
// EJEMPLOS:
//  - ordenarPrecios([20,15,45,10,5]) => [5,10,15,20,45]
//  - ordenarPrecios([20,15,0,10,5]) => false

// CONSIGNAS:
//  üü¢ En caso de recibir un 0 (cero) dentro del array, la funci√≥n debe retornar false.
//  üü¢ Caso contrario, debe retornar un array con los precios ordenados, utilizando alguno de los m√©todo de ordenamiento
//    estudiados. NO SE PUEDE USAR EL M√âTODO SORT() DE ARRAY.

function ordenarPrecios(arr) {
    // Tu c√≥digo aqu√≠:
  for(let j=0;j<arr.length;j++){
    if(arr[j] === 0){
      return false;
    }
  }
  if(arr.length<2){
    return arr;
  }
  let right = [];
  let left = [];
  let equal = [];
  let pivot = arr[Math.floor((Math.random()*(arr.length)))];
  for(let i=0;i<arr.length;i++){
    if(arr[i]<pivot){
      left.push(arr[i]);
    } else if(arr[i]>pivot){
      right.push(arr[i]);
    } else{
      equal.push(arr[i]);
    }
  }
  return ordenarPrecios(left).concat(equal).concat(ordenarPrecios(right));
};
// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  ordenarPrecios
};
const { BinarySearchTree } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 8Ô∏è‚É£ ***** EJERCICIO 8 ***** -- searchMax() 8Ô∏è‚É£
// Implementar la funci√≥n searchMax dentro del prototipo de BynarySearchTree, que nos servir√° para buscar el precio
// m√°ximo que se encuentra dentro de un BinarySearchTree que contendr√° n√∫meros que representan a los precios de una
// de las g√≥ndolas de Henry Market.
//
// EJEMPLO:
//  - En caso de que nuestro √°rbol de precios sea el siguiente:
//
//             17
//          /      \
//        7         24
//      /  \       /   \
//     3    15    18    32
//    / \                 \
//       4                45
//
// Deber√° retornar 45.
BinarySearchTree.prototype.breadthFirstForEach = function(array, arrayIterator = []) {
  array.push(this.value);
  if(this.left){
    arrayIterator.push(this.left);
  }
  if(this.right){
    arrayIterator.push(this.right);
  }
  let nextNode = arrayIterator.shift();
  if(nextNode){
    nextNode.breadthFirstForEach(array, arrayIterator);
  }
};

BinarySearchTree.prototype.searchMax = function () {
  // Tu c√≥digo aqu√≠:
  let maxNumber = 0;
  let arrayAux = [];
  this.breadthFirstForEach(arrayAux);

  for(let i=0;i<arrayAux.length;i++){
    if(maxNumber < arrayAux[i]){
      maxNumber = arrayAux[i];
    }
  }
  return maxNumber;
};
// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    BinarySearchTree
};

const { BinarySearchTree } = require("../DS");

// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 9Ô∏è‚É£ ***** EJERCICIO 9 ***** - searchPrice() 9Ô∏è‚É£
// Implementar la funci√≥n searchPrice dentro del prototipo de BynarySearchTree, que nos servir√° para buscar un precio
// recibido por par√°metro dentro de un BinarySearchTree que contendr√° n√∫meros que representan a los precios de una de
// las g√≥ndolas de Henry Market.
// üü¢ En caso de encontrar el precio recibido por par√°metro, debe retornar true.
// üü¢ En caso de no encontrar dicho precio, debe retornar false.
// üü¢ En caso de recibir por par√°metro un precio igual o menor a 0 (cero), debe retornar el string "Error".
//
// EJEMPLOS:
//  - En caso de que nuestro √°rbol de precios sea el siguiente:
//
//             17
//          /      \
//        7         24
//      /  \       /   \
//     3    15    18    32
//    / \                 \
//       4                45
//
// arbolDePrecios.searchPrice(24) => true
// arbolDePrecios.searchPrice(4) => true
// arbolDePrecios.searchPrice(50) => false
// arbolDePrecios.searchPrice(1) => false
// arbolDePrecios.searchPrice(0) => "Error"
// arbolDePrecios.searchPrice(-10) => "Error"

BinarySearchTree.prototype.searchPrice = function (precio) {
    // Tu c√≥digo aqu√≠
    if(precio <= 0){
        return 'Error';
    }
    if(this.value === precio){
        return true;
    }
    if(this.value < precio && this.right !== null){ 
      return this.right.searchPrice(precio);
    } else if(this.value > precio && this.left !== null){
     return this.left.searchPrice(precio);
    }
    return false;
};


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
 BinarySearchTree
};
// 1Ô∏è‚É£0Ô∏è‚É£  EJERCICIO 10  ingresoEmpleado 1Ô∏è‚É£0Ô∏è‚É£
// Implementar la funci√≥n ingresoEmpleado que servir√° para registrar el ingreso de los empleados del Henry Market,
// apuntando aquellos que hayan llegado a horario.
// IMPORTANTE! Los horarios ser√°n n√∫meros enteros (9,10,11,12), NO tendr√°n formato hora (09:00, 10:00, etc).
//
// La funci√≥n ingresoEmpleado debe retornar la funci√≥n ingresosHorario, la cual recibir√° un arreglo de empleados que ingresan
// al supermercado con la siguiente forma:
// let empleados =  [
//    {nombre:"Jorge", ingresoA: 9}
//    {nombre:"Mora", ingresoA: 8}
//    {nombre:"Mati", ingresoA: 10}
//    {nombre:"Juani", ingresoA: 7}
//  ]
//, y retornar√° un nuevo arreglo con LOS NOMBRES de aquellos que se hayan presentado antes del horario de ingreso.
//
// Ejemplo 
//  const ingresosHorario =  ingresoEmpleado(9)
//  Si ejecuto ingresosHorario(empleados) me daria de resultado ["Jorge"]

function ingresoEmpleado(horario) {
// Tu c√≥digo aqu√≠:
    return function(employees){
        let arrayEmploys = [];
        for(let i=0;i<employees.length;i++){
            if(employees[i]['ingresoA'] < horario){
                arrayEmploys.push(employees[i]['nombre']);
            }
        }
        return arrayEmploys;
    }
}


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    ingresoEmpleado
};

const { Queue } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// üõí HENRY MARKET üõí
// En el d√≠a de inauguraci√≥n del nuevo supermercado Henry Market, estamos encargados
// del correcto funcionamiento de los programas de cada una de las computadoras que
// realizan las distintas tareas en el negocio.
//
// Cada uno de los ejercicios nos pedir√° implementar una funci√≥n en la que utilizaremos
// lo aprendido en este m√≥dulo.
// Leer atentamente cada uno de los enunciados y guiarse por los ejemplos!
//
//
//
//
// 1Ô∏è‚É£ ***** EJERCICIO 1 ***** - henryParking() 1Ô∏è‚É£
// Implementar la funci√≥n henryParking, que nos permitir√° organizar los movimientos de
// los veh√≠culos del estacionamiento de Henry Market..
// La funci√≥n recibir√° por par√°metro un array que representa en orden las entradas
// y salidas de veh√≠culos que se producen en el estacionamiento, y deber√° crear
// una QUEUE, donde iremos registrando los ingresos y egresos.
//
// El array de movimientos tendr√° la siguiente forma:
//
// [23, 43, "OUT", 65, "OUT", 32, 55, "OUT"] , donde cada n√∫mero representa el ingreso
// de un veh√≠culo al que se le asigna dicho valor; y cada "OUT" representa la salida
// del veh√≠culo que lleva m√°s tiempo dentro del estacionamiento.
// Finalmente, la funci√≥n debe retornar la QUEUE que representa el estado del estacionamiento
// al momento de finalizar los eventos del array.
//
// EJEMPLOS:
//
//  - henryParking([23, 43, "OUT", 65]) => Queue [43, 65]
//      - Ingres√≥ veh√≠culo 23. [23] üî∫
//      - Ingres√≥ veh√≠culo 43. [23, 43] üî∫
//      - Egres√≥ veh√≠culo 23.  [43] üîª
//      - Ingres√≥ veh√≠culo 65. [43, 65] üî∫
//
// REQUISITOS:
//  üü¢ La funci√≥n debe retornar la QUEUE resultante de procesar los movimientos.
//  üü¢ Si la funci√≥n intenta retirar un veh√≠culo cuando la Queue se encuentra vac√≠a,
//    debe retornar false
//  üü¢ ATENCI√ìN! La QUEUE que retorna la funci√≥n debe ser una instancia de la clase QUEUE.

function henryParking(arr) {
  // Tu c√≥digo aqu√≠:
  let queueResult = new Queue;
  for(let i=0;i<arr.length;i++){
    if(typeof arr[i] === 'number'){
      queueResult.enqueue(arr[i]);
    } else if((arr[i] === 'OUT')&&(queueResult.size() >= 1)){
      queueResult.dequeue();
    } else{
      return false;
    }
  }
  return queueResult;
};

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  henryParking
};
// 2Ô∏è‚É£ ***** EJERCICIO 2 ***** - calcularIndice() 2Ô∏è‚É£
// En este ejercicio, debemos implementar la funci√≥n calcularIndice, la debe retornar
// un valor num√©rico que es parte de una secuencia de n√∫meros que representa los √≠ndices
// de precios que se aplicar√°n en Henry Market en cada a√±o de actividad.
// La funci√≥n recibir√° por par√°metro el a√±o de actividad del supermercado (valor n√∫m√©rico 0 o mayor),
// y calcular√° el √≠ndice en base a la siguiente secuencia:
//
// - Para el a√±o 0 (n=0) de actividad, el √≠ndice es de 15
// - Para el a√±o 1 (n=1) de actividad, el √≠ndice es 25
// - A partir del a√±o 2, el √≠ndice se calcula con la f√≥rmula f(n-1)+f(n-2)
//
// EJEMPLOS:
// - calcularIndice(0) => 15
// - calcularIndice(1) => 25
// - calcularIndice(2) => calcularIndice(2-1) + calcularIndice(2-2) => 40
// - calcularIndice(3) => calcularIndice(3-1) + calcularIndice(3-2) => 65
//
// REQUISITOS:
//  üü¢ La funci√≥n debe obtener el √≠ndice hallando de forma recursiva el valor correspondiente a n dentro de la secuencia.
//  üü¢ La funci√≥n debe retornar el valor num√©rico correspondiente a n dentro de la secuencia.
//  üü¢ Si el valor de n recibido por par√°metro es menor a 0, debe retornar false.

const calcularIndice = (n) => {
  // Tu c√≥digo aqu√≠:
  if(n<0){
    return false;
  } else if(n === 0){
    return 15;
  } else if(n === 1){
    return 25;
  } else{
    return calcularIndice(n-1) + calcularIndice(n-2);
  }
};


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  calcularIndice
};

const { Stack } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 3Ô∏è‚É£ ***** EJERCICIO 3 ***** - apilarCajas() 3Ô∏è‚É£
// Se debe implementar la funci√≥n apilarCajas, la cual ayudar√° a los encargados de dep√≥sito de
// Henry Market a armar pilas de cajas de productos de forma tal que no supere el peso m√°ximo permitido
// y evitar as√≠ que se da√±en los productos..
// La funci√≥n recibir√° un array que representar√° las cajas que se desean apilar, con el nombre del producto
// y el peso total de cada caja, y deber√° crear y retornar un STACK con LOS NOMBRES de productos que vaya apilando,
// sin superar el peso m√°ximo permitido.
// En caso de que los productos superen dicho peso m√°ximo, deber√° retornar el string "No se puede crear la pila"
// Si el array recibido no contiene cajas, debe retornar el string "Error".

// El array recibido tendr√°, por ejemplo, la siguiente forma:
//
// [
//  {nombre: arroz, peso: 10},
//  {nombre: fideos, peso: 15},
//  {nombre: cafe, peso: 5},
//  {nombre: arroz, peso: 10},
//  {nombre: azucar, peso: 20}
// ]
//
// TIPs:
//  - El array recibido es una ARRAY DE OBJETOS
//  - El array puede contener productos repetidos
//
//                     ********* El peso m√°ximo permitido para cada STACK es de 50 kg! ***********
//
// EJEMPLOS:
//  - apilarCajas( [{nombre: arroz, peso: 10},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => Stack [arroz, fideos, cafe]
//                  * El peso total (30), no supera el m√°ximo (50)
//
//  - apilarCajas( [{nombre: leche, peso: 30},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => Stack [leche, fideos, cafe]
//                  * El peso total (50), no supera el m√°ximo (50)
//
//  - apilarCajas( [{nombre: leche, peso: 30},
//                  {nombre: fideos, peso: 15},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => "No se puede crear la pila"
//                  * El peso total (65), excede el peso m√°ximo permitido (50)
//
//  - apilarCajas( [] ) => "Error"
//
// REQUISITOS:
//  üü¢ La funci√≥n debe crear y retornar el Stack creado con las cajas de productos recibidas en el array
//  üü¢ El Stack que retorna debe ser una instancia de la clase Stack
//  üü¢ En caso de exceder el peso m√°ximo permitido, debe retornar en string "No se puede crear la pila"
//  üü¢ En caso de recibir un array vac√≠o, debe retornar el string "Error"
//
// ATENCI√ìN! Las respuestas en strings son case sensitive!
//

function apilarCajas(arr) {
  // Tu c√≥digo aqu√≠
  if(arr.length === 0){
    return 'Error'; 
  }
  let stackWeigth = 0;
  for(let i=0;i<arr.length;i++){
    stackWeigth += arr[i]['peso'];
  }
  if(stackWeigth >  50){
    return "No se puede crear la pila";
  } else{
    let marketStack = new Stack;
    for(let j=0;j<arr.length;j++){
      marketStack.push(arr[j]['nombre']);
    }
    return marketStack;
  }
};
// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    apilarCajas
};function Queue() {
  this.array = [];
}

Queue.prototype.enqueue = function(elemento) {
  return this.array.push(elemento);
}

Queue.prototype.dequeue = function() {
  return this.array.shift();
}

Queue.prototype.size = function() {
  return this.array.length;
}

function Stack(){
  this.array = [];
}

Stack.prototype.push = function(elemento){
  this.array.push(elemento);
};

Stack.prototype.pop = function(){
  return this.array.pop();
};

Stack.prototype.size = function () {
  return this.array.length;
};


function LinkedList() {
  this.head = null;
}

LinkedList.prototype.add = function(valor) {
  var nuevoNodo = new Node(valor);

  if(!this.head){
    this.head = nuevoNodo;
  } else {
    var tailActual = this.head;
    while (tailActual.next !== null) {
      tailActual = tailActual.next;
    }
    tailActual.next = nuevoNodo;
  }
}

LinkedList.prototype.remove = function() {
  if(!this.head){
    return undefined;
  }

  if(this.head.next === null){
    var unicoNodo = this.head;
    this.head = null;
    return unicoNodo.value;
  }

  var nodoActual = this.head.next;
  var nodoPrevious = this.head;
  while (nodoActual.next !== null) {
    nodoPrevious = nodoActual;
    nodoActual = nodoActual.next;
  }
  nodoPrevious.next = null;
  return nodoActual.value;
}

LinkedList.prototype.search = function(arg) {
  var nodoActual = this.head;

  if(nodoActual === null){
    return null;
  }

  while (nodoActual !== null) {
    if(typeof arg === "function"){
      if(arg(nodoActual.value)){
        return nodoActual.value;
      }
    } else if(nodoActual.value === arg){
        return nodoActual.value;
    }
    nodoActual = nodoActual.next;
  }

  return null;
}

function Node(valor){
  this.value = valor;
  this.next = null;
}

function BinarySearchTree(valor) {
  this.value = valor;
  this.left = null;
  this.right = null;
}

BinarySearchTree.prototype.insert = function(value) {

  if(value < this.value){
    if(this.left === null){
      var newTree = new BinarySearchTree(value);
      this.left = newTree;
    } else {
      this.left.insert(value);
    }
  } else {
    if(this.right === null){
      var newTree = new BinarySearchTree(value);
      this.right = newTree;
    } else {
      this.right.insert(value);
    }
  }
}

BinarySearchTree.prototype.size = function() {
  if(this.value === null){
    return 0;
  }

  if(this.left === null && this.right === null){
    return 1;
  }

  if(this.left === null){
    return 1 + this.right.size();
  }

  if(this.right === null){
    return 1 + this.left.size();
  }

  return 1 + this.left.size() + this.right.size();
}


module.exports = {
  Queue,
  Stack,
  Node,
  LinkedList,
  BinarySearchTree
};
