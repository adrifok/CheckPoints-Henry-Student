
// 7Ô∏è‚É£ ***** EJERCICIO 7 ***** - ordenarPrecios() 7Ô∏è‚É£
// Implementar la funci√≥n ordenarPrecios, la cual recibir√° un array que representa una lista desordenada
// de precios de Henry Market y, a trav√©s de alguno de los m√©todos de ordenamiento vistos en el m√≥dulo (a elecci√≥n),
// deber√° retornar un array con los precios ordenados de menor a mayor.
// As√≠mismo, en caso de que la funci√≥n se encuentre con alg√∫n precio 0 (cero) dentro del array, debe desestimar
// el ordenamiento, y retornar false.
//
// EJEMPLOS:
//  - ordenarPrecios([20,15,45,10,5]) => [5,10,15,20,45]
//  - ordenarPrecios([20,15,0,10,5]) => false

// CONSIGNAS:
//  üü¢ En caso de recibir un 0 (cero) dentro del array, la funci√≥n debe retornar false
//  üü¢ Caso contrario, debe retornar un array con los precios ordenados, utilizando alguno de los m√©todo de ordenamiento
//    estudiados. NO SE PUEDE USAR EL M√âTODO SORT() DE ARRAY.

function ordenarPrecios(arr) {
  // Tu c√≥digo aqu√≠:
  if (arr.includes(0)) return false;
  if (arr.length <= 1) return arr;

  // Separar derecha, izquierda y pivote
  let pivot = [];
  let izq = [];
  let der = [];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > pivot) {
      der.push(arr[i]);
    } else if
      (arr[i] < pivot){
      izq.push(arr[i]);
    }else{
      pivot.push(arr[i]);
    }
  }
  return ordenarPrecios(izq).concat(pivot).concat(ordenarPrecios(der));
}
// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  ordenarPrecios
};
const { BinarySearchTree } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 8Ô∏è‚É£ ***** EJERCICIO 8 ***** - searchMax() 8Ô∏è‚É£
// Implementar la funci√≥n searchMax dentro del prototipo de BynarySearchTree, que nos servir√° para buscar el precio
// m√°ximo que se encuentra dentro de un BinarySearchTree que contendr√° n√∫meros que representan a los precios de una
// de las g√≥ndolas de Henry Market.
//
// EJEMPLO:
//  - En caso de que nuestro √°rbol de precios sea el siguiente:
//
//             17
//          /      \
//        7         24
//      /  \       /   \
//     3    15    18    32
//    / \                 \
//       4                45
//
// Deber√° retornar 45.

BinarySearchTree.prototype.searchMax = function () {
  // Tu c√≥digo aqu√≠:
  let pila = [];      
  let visitados = []; 
  let current = this;
  pila.push(current);
  while(pila.length != 0) {
    current = pila.pop();
    visitados.push(current.value);
    if (current.right) pila.push(current.right);
    if (current.left) pila.push(current.left);
  }
  visitados.sort((a, b) => (a < b ? 1 : -1));
  let arrayFinal = visitados.splice(0, 1);
  return arrayFinal[0];
};
// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    BinarySearchTree
};

const { BinarySearchTree } = require("../DS");

// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 9Ô∏è‚É£ ***** EJERCICIO 9 ***** - searchPrice() 9Ô∏è‚É£
// Implementar la funci√≥n searchPrice dentro del prototipo de BynarySearchTree, que nos servir√° para buscar un precio
// recibido por par√°metro dentro de un BinarySearchTree que contendr√° n√∫meros que representan a los precios de una de
// las g√≥ndolas de Henry Market.
// üü¢ En caso de encontrar el precio recibido por par√°metro, debe retornar true.
// üü¢ En caso de no encontrar dicho precio, debe retornar false.
// üü¢ En caso de recibir por par√°metro un precio igual o menor a 0 (cero), debe retornar el string "Error"
//
// EJEMPLOS:
//  - En caso de que nuestro √°rbol de precios sea el siguiente:
//
//             17
//          /      \
//        7         24
//      /  \       /   \
//     3    15    18    32
//    / \                 \
//       4                45
//
// arbolDePrecios.searchPrice(24) => true
// arbolDePrecios.searchPrice(4) => true
// arbolDePrecios.searchPrice(50) => false
// arbolDePrecios.searchPrice(1) => false
// arbolDePrecios.searchPrice(0) => "Error"
// arbolDePrecios.searchPrice(-10) => "Error"

BinarySearchTree.prototype.searchPrice = function (precio) {
  // Tu c√≥digo aqu√≠
  /*if (precio <= 0) return 'Error';
  if (this.value === precio) return true;
  if (precio < this.value) {
    if (this.left === null) return false;
    return this.left.searchPrice(precio);
  }
  if (precio > this.value) {
    if (this.right === null) return false;
    return this.right.searchPrice(precio);
  }
};*/

if(precio <= 0){
  return 'Error';
}
if(this.value === precio){
  return true;
}
if(this.value < precio && this.right !== null){ 
return this.right.searchPrice(precio);
} else if(this.value > precio && this.left !== null){
return this.left.searchPrice(precio);
}
return false;
};


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
 BinarySearchTree
};
// 1Ô∏è‚É£0Ô∏è‚É£  EJERCICIO 10  ingresoEmpleado 1Ô∏è‚É£0Ô∏è‚É£
// Implementar la funci√≥n ingresoEmpleado que servir√° para registrar el ingreso de los empleados del Henry Market,
// apuntando aquellos que hayan llegado a horario.
// IMPORTANTE! Los horarios ser√°n n√∫meros enteros (9,10,11,12), NO tendr√°n formato hora (09:00, 10:00, etc)
//
// La funci√≥n ingresoEmpleado debe retornar la funci√≥n ingresosHorario, la cual recibir√° un arreglo de empleados que ingresan
// al supermercado con la siguiente forma:
// let empleados =  [
//    {nombre:"Jorge", ingresoA: 9}
//    {nombre:"Mora", ingresoA: 8}
//    {nombre:"Mati", ingresoA: 10}
//    {nombre:"Juani", ingresoA: 7}
//  ]
//, y retornar√° un nuevo arreglo con LOS NOMBRES de aquellos que se hayan presentado antes del horario de ingreso.
//
// Ejemplo 
//  const ingresosHorario =  ingresoEmpleado(9)
//  Si ejecuto ingresosHorario(empleados) me daria de resultado ["Jorge"]

function ingresoEmpleado(horario) {
  // Tu c√≥digo aqu√≠:
  return function (array) {
    let resultado = [];
    array.forEach((objeto) => {
      if (objeto.ingresoA < horario) {
        resultado.push(objeto.nombre);
      }
    });
    return resultado;
  };
}


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    ingresoEmpleado
};

function Queue() {
  this.array = [];
}

Queue.prototype.enqueue = function(elemento) {
  return this.array.push(elemento);
}

Queue.prototype.dequeue = function() {
  return this.array.shift();
}

Queue.prototype.size = function() {
  return this.array.length;
}

function Stack(){
  this.array = [];
}

Stack.prototype.push = function(elemento){
  this.array.push(elemento);
};

Stack.prototype.pop = function(){
  return this.array.pop();
};

Stack.prototype.size = function () {
  return this.array.length;
};


function LinkedList() {
  this.head = null;
}

LinkedList.prototype.add = function(valor) {
  var nuevoNodo = new Node(valor);

  if(!this.head){
    this.head = nuevoNodo;
  } else {
    var tailActual = this.head;
    while (tailActual.next !== null) {
      tailActual = tailActual.next;
    }
    tailActual.next = nuevoNodo;
  }
}

LinkedList.prototype.remove = function() {
  if(!this.head){
    return undefined;
  }

  if(this.head.next === null){
    var unicoNodo = this.head;
    this.head = null;
    return unicoNodo.value;
  }

  var nodoActual = this.head.next;
  var nodoPrevious = this.head;
  while (nodoActual.next !== null) {
    nodoPrevious = nodoActual;
    nodoActual = nodoActual.next;
  }
  nodoPrevious.next = null;
  return nodoActual.value;
}

LinkedList.prototype.search = function(arg) {
  var nodoActual = this.head;

  if(nodoActual === null){
    return null;
  }

  while (nodoActual !== null) {
    if(typeof arg === "function"){
      if(arg(nodoActual.value)){
        return nodoActual.value;
      }
    } else if(nodoActual.value === arg){
        return nodoActual.value;
    }
    nodoActual = nodoActual.next;
  }

  return null;
}

function Node(valor){
  this.value = valor;
  this.next = null;
}

function BinarySearchTree(valor) {
  this.value = valor;
  this.left = null;
  this.right = null;
}

BinarySearchTree.prototype.insert = function(value) {

  if(value < this.value){
    if(this.left === null){
      var newTree = new BinarySearchTree(value);
      this.left = newTree;
    } else {
      this.left.insert(value);
    }
  } else {
    if(this.right === null){
      var newTree = new BinarySearchTree(value);
      this.right = newTree;
    } else {
      this.right.insert(value);
    }
  }
}

BinarySearchTree.prototype.size = function() {
  if(this.value === null){
    return 0;
  }

  if(this.left === null && this.right === null){
    return 1;
  }

  if(this.left === null){
    return 1 + this.right.size();
  }

  if(this.right === null){
    return 1 + this.left.size();
  }

  return 1 + this.left.size() + this.right.size();
}


module.exports = {
  Queue,
  Stack,
  Node,
  LinkedList,
  BinarySearchTree
};

const { Queue } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// üõí HENRY MARKET üõí
// En el d√≠a de inauguraci√≥n del nuevo supermercado Henry Market, estamos encargados
// del correcto funcionamiento de los programas de cada una de las computadoras que
// realizan las distintas tareas en el negocio.
//
// Cada uno de los ejercicios nos pedir√° implementar una funci√≥n en la que utilizaremos
// lo aprendido en este m√≥dulo.
// Leer atentamente cada uno de los enunciados y guiarse por los ejemplos!
//
//
//
//
// 1Ô∏è‚É£ ***** EJERCICIO 1 ***** - henryParking() 1Ô∏è‚É£
// Implementar la funci√≥n henryParking, que nos permitir√° organizar los movimientos de
// los veh√≠culos del estacionamiento de Henry Market.
// La funci√≥n recibir√° por par√°metro un array que representa en orden las entradas
// y salidas de veh√≠culos que se producen en el estacionamiento, y deber√° crear
// una QUEUE, donde iremos registrando los ingresos y egresos.
//
// El array de movimientos tendr√° la siguiente forma:
//
// [23, 43, "OUT", 65, "OUT", 32, 55, "OUT"] , donde cada n√∫mero representa el ingreso
// de un veh√≠culo al que se le asigna dicho valor; y cada "OUT" representa la salida
// del veh√≠culo que lleva m√°s tiempo dentro del estacionamiento.
// Finalmente, la funci√≥n debe retornar la QUEUE que representa el estado del estacionamiento
// al momento de finalizar los eventos del array.
//
// EJEMPLOS:
//
//  - henryParking([23, 43, "OUT", 65]) => Queue [43, 65]
//      - Ingres√≥ veh√≠culo 23. [23] üî∫
//      - Ingres√≥ veh√≠culo 43. [23, 43] üî∫
//      - Egres√≥ veh√≠culo 23.  [43] üîª
//      - Ingres√≥ veh√≠culo 65. [43, 65] üî∫
//
// REQUISITOS:
//  üü¢ La funci√≥n debe retornar la QUEUE resultante de procesar los movimientos.
//  üü¢ Si la funci√≥n intenta retirar un veh√≠culo cuando la Queue se encuentra vac√≠a,
//    debe retornar false
//  üü¢ ATENCI√ìN! La QUEUE que retorna la funci√≥n debe ser una instancia de la clase QUEUE.

function henryParking(arr) {
  // Tu c√≥digo aqu√≠:

  let cola = new Queue();
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== 'string') cola.enqueue(arr[i]);
    if (typeof arr[i] === 'OUT') {
      if (cola.size() === 0) return false;
      cola.dequeue();
    }
  }
  return cola;
}


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  henryParking
};
// 2Ô∏è‚É£ ***** EJERCICIO 2 ***** - calcularIndice() 2Ô∏è‚É£
// En este ejercicio, debemos implementar la funci√≥n calcularIndice, la debe retornar
// un valor num√©rico que es parte de una secuencia de n√∫meros que representa los √≠ndices
// de precios que se aplicar√°n en Henry Market en cada a√±o de actividad.
// La funci√≥n recibir√° por par√°metro el a√±o de actividad del supermercado (valor n√∫m√©rico 0 o mayor),
// y calcular√° el √≠ndice en base a la siguiente secuencia:
//
// - Para el a√±o 0 (n=0) de actividad, el √≠ndice es de 15
// - Para el a√±o 1 (n=1) de actividad, el √≠ndice es 25
// - A partir del a√±o 2, el √≠ndice se calcula con la f√≥rmula f(n-1)+f(n-2)
//
// EJEMPLOS:
// - calcularIndice(0) => 15
// - caluclarIndice(1) => 25
// - calcularIndice(2) => calcularIndice(2-1) + calcularIndice(2-2) => 40
// - calcularIndice(3) => calcularIndice(3-1) + calcularIndice(3-2) => 65
//
// REQUISITOS:
//  üü¢ La funci√≥n debe obtener el √≠ndice hallando de forma recursiva el valor correspondiente a n dentro de la secuencia.
//  üü¢ La funci√≥n debe retornar el valor num√©rico correspondiente a n dentro de la secuencia.
//  üü¢ Si el valor de n recibido por par√°metro es menor a 0, debe retornar false.

const calcularIndice = (n) => {
  // Tu c√≥digo aqu√≠:
  if (n < 0) return false;
  if (n === 0) return 15;
  if (n === 1) return 25;
  return calcularIndice(n - 1) + calcularIndice(n - 2);
}


// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  calcularIndice
};

const { Stack } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 3Ô∏è‚É£ ***** EJERCICIO 3 ***** - apilarCajas() 3Ô∏è‚É£
// Se debe implementar la funci√≥n apilarCajas, la cual ayudar√° a los encargados de dep√≥sito de
// Henry Market a armar pilas de cajas de productos de forma tal que no supere el peso m√°ximo permitido
// y evitar as√≠ que se da√±en los productos.
// La funci√≥n recibir√° un array que representar√° las cajas que se desean apilar, con el nombre del producto
// y el peso total de cada caja, y deber√° crear y retornar un STACK con LOS NOMBRES de productos que vaya apilando,
// sin superar el peso m√°ximo permitido.
// En caso de que los productos superen dicho peso m√°ximo, deber√° retornar el string "No se puede crear la pila"
// Si el array recibido no contiene cajas, debe retornar el string "Error".

// El array recibido tendr√°, por ejemplo, la siguiente forma:
//
// [
//  {nombre: arroz, peso: 10},
//  {nombre: fideos, peso: 15},
//  {nombre: cafe, peso: 5},
//  {nombre: arroz, peso: 10},
//  {nombre: azucar, peso: 20}
// ]
//
// TIPs:
//  - El array recibido es una ARRAY DE OBJETOS
//  - El array puede contener productos repetidos
//
//                     ********* El peso m√°ximo permitido para cada STACK es de 50 kg! ***********
//
// EJEMPLOS:
//  - apilarCajas( [{nombre: arroz, peso: 10},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => Stack [arroz, fideos, cafe]
//                  * El peso total (30), no supera el m√°ximo (50)
//
//  - apilarCajas( [{nombre: leche, peso: 30},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => Stack [leche, fideos, cafe]
//                  * El peso total (50), no supera el m√°ximo (50)
//
//  - apilarCajas( [{nombre: leche, peso: 30},
//                  {nombre: fideos, peso: 15},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => "No se puede crear la pila"
//                  * El peso total (65), excede el peso m√°ximo permitido (50)
//
//  - apilarCajas( [] ) => "Error"
//
// REQUISITOS:
//  üü¢ La funci√≥n debe crear y retornar el Stack creado con las cajas de productos recibidas en el array
//  üü¢ El Stack que retorna debe ser una instancia de la clase Stack
//  üü¢ En caso de exceder el peso m√°ximo permitido, debe retornar en string "No se puede crear la pila"
//  üü¢ En caso de recibir un array vac√≠o, debe retornar el string "Error"
//
// ATENCI√ìN! Las respuestas en strings son case sensitive!
//

function apilarCajas(arr) {
  // Tu c√≥digo aqu√≠
  if (arr.length === 0) return 'Error';
  let pila = new Stack();
  let pesoTotal = 0;
  arr.forEach(objeto => {
    pesoTotal += objeto.peso;
    pila.push(objeto.nombre);
  });
  if (pesoTotal > 50) return 'No se puede crear la pila';
    return pila;
}
// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    apilarCajas
};
// 4Ô∏è‚É£ ***** EJERCICIO 4 ***** - devuelveMayores() 4Ô∏è‚É£

// Implementar la funci√≥n devuelveMayores, que recibe por par√°metro una LinkedList con precios
// de productos de una determinada g√≥ndola de Henry Market, y un precio m√°ximo a evaluar.
// La funci√≥n deber√° recorrer la LinkedList recibida y retornar la CANTIDAD DE PRECIOS QUE SUPEREN
// el valor de precio m√°ximo que se desea evaluar.
// En caso de que ning√∫n precio supere dicho valor, debe retornar en string "Sin precios"

//  EJEMPLOS:
//
//  listaPrecios1 = 5 => 10 => 8 => 7 => 14 => 20
//  devuelveMayores(listaPrecios1, 10) => 2
//  (2 precios (14 y 20) superan el valor a evaluar (10))
//
//  listaPrecios2 = 99 => 100 => 81 => 74 => 14 => 22
//  devuelveMayores(listaPrecios2, 50) => 4
//  (4 precios (99, 100, 81 y 74) superan el valor a evaluar (50))
//
//  listaPrecios3 = 99 => 80 => 81 => 75 => 15 => 21
//  devuelveMayores(listaPrecios3, 100) => "Sin precios"
//  (Ning√∫n precio de la lista supera el valor a evaluar (100))
//
//  REQUISITOS:
//    üü¢ La funci√≥n debe retornar un valor num√©rico, que representa la CANTIDAD DE PRECIOS que superen
//      el valor a evaluar.
//    üü¢ En caso de que ning√∫n precio supere dicho valor, debe retornar el string "Sin precios"
//
//  ATENCI√ìN! Las respuestas en strings son case sensitive!

function devuelveMayores(lista, valor) {
  // Tu c√≥digo aqu√≠:
  let nodoActual = lista.head;
  //console.log(nodoActual);
  let cantidad = 0;
  while (nodoActual) {
    if (nodoActual.value > valor) cantidad++;
  }
    nodoActual = nodoActual.next;
  }
  if (cantidad === 0) return 'Sin precios';
  return cantidad;
}

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  devuelveMayores
};
// 5Ô∏è‚É£ ***** EJERCICIO 5 ***** - cobrarClientes 5Ô∏è‚É£

// Implementar la funci√≥n cobrarClientes, que recibir√° una
// Queue (fila) de clientes que esperan para realizar el pago
// de sus compras del supermercado.
//
// Cada cliente dentro de la fila estar√° como objeto, y tendr√°
// la siguiente estructura:
//
// {
//   nombre: "Jorge",
//   dinero: 1500,
//   precioProductos: 1200
// }
//
// - nombre: Nombre del cliente
// - dinero: Dinero disponible que tiene el cliente
// - precioProductos: Suma de los productos que desea comprar
//
// La funci√≥n debe evaluar si el primer cliente de la fila poseee dinero suficiente
// para abonar los productos que desea comprar. En caso de ser as√≠, debe remover
// al cliente de la fila.
// En caso de presentarse un cliente que no posee dinero suficiente, debe dejar de
// evaluar los clientes de la fila, y retornar un array con los NOMBRES de los clientes
// que fueron correctamente retirados de la fila.
//
// EJEMPLO:
//
// clientes=[
//  {
//   nombre: "Jorge",
//   dinero: 1500,
//   precioProductos: 1200
//  },
//  {
//   nombre: "Mateo",
//   dinero: 2000,
//   precioProductos: 1900
//  },
//  {
//   nombre: "Mora",
//   dinero: 5000,
//   precioProductos: 5500
//  },
//]
//
// cobrarClientes(clientes) => ["Jorge","Mateo"]
//
// ‚ö†Ô∏è ATENCI√ìN ‚ö†Ô∏è
// Recuerden que los "clientes" recibidos por par√°metro se encuentran
// en una Queue! Por lo cual tendremos que utilizar los m√©todos que
// tenemos implementados para esta clase.
//
// CONSIGNAS:
//  üü¢ Cuando termine de evaluar clientes, la funci√≥n debe retornar un array con los nombres de los clientes que
//    han abonado correctamente.
//  üü¢ En caso de quedarse sin clientes en la fila, la funci√≥n debe retornar false.

function cobrarClientes(clientes) {
  // Tu c√≥digo aqu√≠:
  let retirados = [];
  while (clientes.array[0].dinero >= clientes.array[0].precioProductos) {
    retirados.push(clientes.array[0].nombre);
    clientes.dequeue();
    if (clientes.size() === 0) return false;
  }
  return retirados;
}

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  cobrarClientes
};
const { BinarySearchTree } = require("../DS");
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

// 6Ô∏è‚É£ ***** EJERCICIO 6 ***** - agregarProductos 6Ô∏è‚É£
// Implementar la funci√≥n agregarProductos(producto) al prototipo de BinarySearchTree, que nos servir√° para
// agregar LOS NOMBRES de los productos en una g√≥ndola de supermercado en base a las comparacionesde sus precios,
// siguiendo la siguiente tabla:
//
//    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//    ‚îÇProductos‚îÇ Precios‚îÇ
//    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
//    ‚îÇ  Leche  ‚îÇ  100   ‚îÇ
//    ‚îÇ  Queso  ‚îÇ  150   ‚îÇ
//    ‚îÇ   Pan   ‚îÇ   50   ‚îÇ
//    ‚îÇ Frutas  ‚îÇ  110   ‚îÇ
//    ‚îÇ  Arroz  ‚îÇ   40   ‚îÇ
//    ‚îÇ  Jugo   ‚îÇ   80   ‚îÇ
//    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//
//  EJEMPLO:
//
//  Si partimos del √°rbol inicial llamado "arbolDeProductos" con un solo nodo:
//
//                                              Leche
//                                              /    \
//
//    arbolDeProductos.agregarProductos(Queso)
//
//                                              Leche
//                                              /    \
//                                                   Queso
//
// El producto "Queso" se insert√≥ a la derecha, ya que su precio (150), es mayor que el precio Leche (100).
//
//    arbolDeProductos.agregarProductos(Pan)
//
//                                             Leche
//                                             /    \
//                                          Pan      Queso
//
// El producto "Pan" se insert√≥ a la izquierda, ya que su precio (50), es menor que el precio Leche (100).
//
//    arbolDeProductos.agregarProductos(Frutas)
//
//                                             Leche
//                                            /     \
//                                         Pan       Queso
//                                                  /
//                                               Frutas
//
// El producto "Frutas" en la posici√≥n correspondiente, ya que su precio (110), supera al de Leche (100) y
// es menor que precio de Queso (150).
//
// CONSIGNAS:
//  üü¢ En caso de querer insertar un producto que ya se encuentra en el √°rbol, debe retornar
//    el string "Ya existe el producto".
//  üü¢ En caso de querer insertar un producto que no se encuentra en la tabla de precios, debe retornar
//    el string "Producto inexistente".
//  üü¢ El m√©todo debe insertar el producto en la posici√≥n correspondiente, basando su ubicaci√≥n en el
//    precio del producto. (Ver ejemplos)
//  üü¢ En caso de insertar el producto correctamente, debe retornar el nuevo nodo que ha sido insertado.
//
//
// IMPORTANTE! La lista de productos se encuentra en el objeto productos a continuaci√≥n:
//‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è

//‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è

BinarySearchTree.prototype.agregarProductos = function (nombreProducto, productos) {
  // Tu c√≥digo aqu√≠:
  if (!productos.hasOwnProperty(nombreProducto)) return 'Producto inexistente';
  let vuelta;
  let temporal = this.value;
  if (nombreProducto === temporal) return 'Ya existe el producto';
  if (productos[nombreProducto] < productos[temporal]) {
    if (this.left === null) {
      var newTree = new BinarySearchTree(nombreProducto);
      this.left = newTree;
      return this.left;
    } else {
      return this.left.agregarProductos(nombreProducto, productos);
    }
  } else {
    if (this.right === null) {
      var newTree = new BinarySearchTree(nombreProducto);
      this.right = newTree;
      return this.right;
    } else {
      return this.right.agregarProductos(nombreProducto, productos);
    }
  }
};

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
    BinarySearchTree
};
