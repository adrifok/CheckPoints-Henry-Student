
// 7ï¸âƒ£ ***** EJERCICIO 7 ***** - ordenarPrecios() 7ï¸âƒ£
// Implementar la funciÃ³n ordenarPrecios, la cual recibirÃ¡ un array que representa una lista desordenada
// de precios de Henry Market y, a travÃ©s de alguno de los mÃ©todos de ordenamiento vistos en el mÃ³dulo (a elecciÃ³n),
// deberÃ¡ retornar un array con los precios ordenados de menor a mayor.
// AsÃ­mismo, en caso de que la funciÃ³n se encuentre con algÃºn precio 0 (cero) dentro del array, debe desestimar
// el ordenamiento, y retornar false.
//
// EJEMPLOS:
//  - ordenarPrecios([20,15,45,10,5]) => [5,10,15,20,45]
//  - ordenarPrecios([20,15,0,10,5]) => false

// CONSIGNAS:
//  ğŸŸ¢ En caso de recibir un 0 (cero) dentro del array, la funciÃ³n debe retornar false
//  ğŸŸ¢ Caso contrario, debe retornar un array con los precios ordenados, utilizando alguno de los mÃ©todo de ordenamiento
//    estudiados. NO SE PUEDE USAR EL MÃ‰TODO SORT() DE ARRAY.

function ordenarPrecios(arr) {
  // Tu cÃ³digo aquÃ­:
  if (arr.includes(0)) return false;
  if (arr.length <= 1) return arr;

  // Separar derecha, izquierda y pivote
  let pivot = [];
  let izq = [];
  let der = [];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > pivot) {
      der.push(arr[i]);
    } else if
      (arr[i] < pivot){
      izq.push(arr[i]);
    }else{
      pivot.push(arr[i]);
    }
  }
  return ordenarPrecios(izq).concat(pivot).concat(ordenarPrecios(der));
}
// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
  ordenarPrecios
};
const { BinarySearchTree } = require("../DS");
// âš ï¸ NO MODIFICAR NADA POR ENCIMA DE ESTA LÃNEA âš ï¸

// 8ï¸âƒ£ ***** EJERCICIO 8 ***** - searchMax() 8ï¸âƒ£
// Implementar la funciÃ³n searchMax dentro del prototipo de BynarySearchTree, que nos servirÃ¡ para buscar el precio
// mÃ¡ximo que se encuentra dentro de un BinarySearchTree que contendrÃ¡ nÃºmeros que representan a los precios de una
// de las gÃ³ndolas de Henry Market.
//
// EJEMPLO:
//  - En caso de que nuestro Ã¡rbol de precios sea el siguiente:
//
//             17
//          /      \
//        7         24
//      /  \       /   \
//     3    15    18    32
//    / \                 \
//       4                45
//
// DeberÃ¡ retornar 45.

BinarySearchTree.prototype.searchMax = function () {
  // Tu cÃ³digo aquÃ­:
  let pila = [];      
  let visitados = []; 
  let current = this;
  pila.push(current);
  while(pila.length != 0) {
    current = pila.pop();
    visitados.push(current.value);
    if (current.right) pila.push(current.right);
    if (current.left) pila.push(current.left);
  }
  visitados.sort((a, b) => (a < b ? 1 : -1));
  let arrayFinal = visitados.splice(0, 1);
  return arrayFinal[0];
};
// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
    BinarySearchTree
};

const { BinarySearchTree } = require("../DS");

// âš ï¸ NO MODIFICAR NADA POR ENCIMA DE ESTA LÃNEA âš ï¸

// 9ï¸âƒ£ ***** EJERCICIO 9 ***** - searchPrice() 9ï¸âƒ£
// Implementar la funciÃ³n searchPrice dentro del prototipo de BynarySearchTree, que nos servirÃ¡ para buscar un precio
// recibido por parÃ¡metro dentro de un BinarySearchTree que contendrÃ¡ nÃºmeros que representan a los precios de una de
// las gÃ³ndolas de Henry Market.
// ğŸŸ¢ En caso de encontrar el precio recibido por parÃ¡metro, debe retornar true.
// ğŸŸ¢ En caso de no encontrar dicho precio, debe retornar false.
// ğŸŸ¢ En caso de recibir por parÃ¡metro un precio igual o menor a 0 (cero), debe retornar el string "Error"
//
// EJEMPLOS:
//  - En caso de que nuestro Ã¡rbol de precios sea el siguiente:
//
//             17
//          /      \
//        7         24
//      /  \       /   \
//     3    15    18    32
//    / \                 \
//       4                45
//
// arbolDePrecios.searchPrice(24) => true
// arbolDePrecios.searchPrice(4) => true
// arbolDePrecios.searchPrice(50) => false
// arbolDePrecios.searchPrice(1) => false
// arbolDePrecios.searchPrice(0) => "Error"
// arbolDePrecios.searchPrice(-10) => "Error"

BinarySearchTree.prototype.searchPrice = function (precio) {
  // Tu cÃ³digo aquÃ­
  /*if (precio <= 0) return 'Error';
  if (this.value === precio) return true;
  if (precio < this.value) {
    if (this.left === null) return false;
    return this.left.searchPrice(precio);
  }
  if (precio > this.value) {
    if (this.right === null) return false;
    return this.right.searchPrice(precio);
  }
};*/

if(precio <= 0){
  return 'Error';
}
if(this.value === precio){
  return true;
}
if(this.value < precio && this.right !== null){ 
return this.right.searchPrice(precio);
} else if(this.value > precio && this.left !== null){
return this.left.searchPrice(precio);
}
return false;
};


// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
 BinarySearchTree
};
// 1ï¸âƒ£0ï¸âƒ£  EJERCICIO 10  ingresoEmpleado 1ï¸âƒ£0ï¸âƒ£
// Implementar la funciÃ³n ingresoEmpleado que servirÃ¡ para registrar el ingreso de los empleados del Henry Market,
// apuntando aquellos que hayan llegado a horario.
// IMPORTANTE! Los horarios serÃ¡n nÃºmeros enteros (9,10,11,12), NO tendrÃ¡n formato hora (09:00, 10:00, etc)
//
// La funciÃ³n ingresoEmpleado debe retornar la funciÃ³n ingresosHorario, la cual recibirÃ¡ un arreglo de empleados que ingresan
// al supermercado con la siguiente forma:
// let empleados =  [
//    {nombre:"Jorge", ingresoA: 9}
//    {nombre:"Mora", ingresoA: 8}
//    {nombre:"Mati", ingresoA: 10}
//    {nombre:"Juani", ingresoA: 7}
//  ]
//, y retornarÃ¡ un nuevo arreglo con LOS NOMBRES de aquellos que se hayan presentado antes del horario de ingreso.
//
// Ejemplo 
//  const ingresosHorario =  ingresoEmpleado(9)
//  Si ejecuto ingresosHorario(empleados) me daria de resultado ["Jorge"]

function ingresoEmpleado(horario) {
  // Tu cÃ³digo aquÃ­:
  return function (array) {
    let resultado = [];
    array.forEach((objeto) => {
      if (objeto.ingresoA < horario) {
        resultado.push(objeto.nombre);
      }
    });
    return resultado;
  };
}


// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
    ingresoEmpleado
};

function Queue() {
  this.array = [];
}

Queue.prototype.enqueue = function(elemento) {
  return this.array.push(elemento);
}

Queue.prototype.dequeue = function() {
  return this.array.shift();
}

Queue.prototype.size = function() {
  return this.array.length;
}

function Stack(){
  this.array = [];
}

Stack.prototype.push = function(elemento){
  this.array.push(elemento);
};

Stack.prototype.pop = function(){
  return this.array.pop();
};

Stack.prototype.size = function () {
  return this.array.length;
};


function LinkedList() {
  this.head = null;
}

LinkedList.prototype.add = function(valor) {
  var nuevoNodo = new Node(valor);

  if(!this.head){
    this.head = nuevoNodo;
  } else {
    var tailActual = this.head;
    while (tailActual.next !== null) {
      tailActual = tailActual.next;
    }
    tailActual.next = nuevoNodo;
  }
}

LinkedList.prototype.remove = function() {
  if(!this.head){
    return undefined;
  }

  if(this.head.next === null){
    var unicoNodo = this.head;
    this.head = null;
    return unicoNodo.value;
  }

  var nodoActual = this.head.next;
  var nodoPrevious = this.head;
  while (nodoActual.next !== null) {
    nodoPrevious = nodoActual;
    nodoActual = nodoActual.next;
  }
  nodoPrevious.next = null;
  return nodoActual.value;
}

LinkedList.prototype.search = function(arg) {
  var nodoActual = this.head;

  if(nodoActual === null){
    return null;
  }

  while (nodoActual !== null) {
    if(typeof arg === "function"){
      if(arg(nodoActual.value)){
        return nodoActual.value;
      }
    } else if(nodoActual.value === arg){
        return nodoActual.value;
    }
    nodoActual = nodoActual.next;
  }

  return null;
}

function Node(valor){
  this.value = valor;
  this.next = null;
}

function BinarySearchTree(valor) {
  this.value = valor;
  this.left = null;
  this.right = null;
}

BinarySearchTree.prototype.insert = function(value) {

  if(value < this.value){
    if(this.left === null){
      var newTree = new BinarySearchTree(value);
      this.left = newTree;
    } else {
      this.left.insert(value);
    }
  } else {
    if(this.right === null){
      var newTree = new BinarySearchTree(value);
      this.right = newTree;
    } else {
      this.right.insert(value);
    }
  }
}

BinarySearchTree.prototype.size = function() {
  if(this.value === null){
    return 0;
  }

  if(this.left === null && this.right === null){
    return 1;
  }

  if(this.left === null){
    return 1 + this.right.size();
  }

  if(this.right === null){
    return 1 + this.left.size();
  }

  return 1 + this.left.size() + this.right.size();
}


module.exports = {
  Queue,
  Stack,
  Node,
  LinkedList,
  BinarySearchTree
};

const { Queue } = require("../DS");
// âš ï¸ NO MODIFICAR NADA POR ENCIMA DE ESTA LÃNEA âš ï¸

// ğŸ›’ HENRY MARKET ğŸ›’
// En el dÃ­a de inauguraciÃ³n del nuevo supermercado Henry Market, estamos encargados
// del correcto funcionamiento de los programas de cada una de las computadoras que
// realizan las distintas tareas en el negocio.
//
// Cada uno de los ejercicios nos pedirÃ¡ implementar una funciÃ³n en la que utilizaremos
// lo aprendido en este mÃ³dulo.
// Leer atentamente cada uno de los enunciados y guiarse por los ejemplos!
//
//
//
//
// 1ï¸âƒ£ ***** EJERCICIO 1 ***** - henryParking() 1ï¸âƒ£
// Implementar la funciÃ³n henryParking, que nos permitirÃ¡ organizar los movimientos de
// los vehÃ­culos del estacionamiento de Henry Market.
// La funciÃ³n recibirÃ¡ por parÃ¡metro un array que representa en orden las entradas
// y salidas de vehÃ­culos que se producen en el estacionamiento, y deberÃ¡ crear
// una QUEUE, donde iremos registrando los ingresos y egresos.
//
// El array de movimientos tendrÃ¡ la siguiente forma:
//
// [23, 43, "OUT", 65, "OUT", 32, 55, "OUT"] , donde cada nÃºmero representa el ingreso
// de un vehÃ­culo al que se le asigna dicho valor; y cada "OUT" representa la salida
// del vehÃ­culo que lleva mÃ¡s tiempo dentro del estacionamiento.
// Finalmente, la funciÃ³n debe retornar la QUEUE que representa el estado del estacionamiento
// al momento de finalizar los eventos del array.
//
// EJEMPLOS:
//
//  - henryParking([23, 43, "OUT", 65]) => Queue [43, 65]
//      - IngresÃ³ vehÃ­culo 23. [23] ğŸ”º
//      - IngresÃ³ vehÃ­culo 43. [23, 43] ğŸ”º
//      - EgresÃ³ vehÃ­culo 23.  [43] ğŸ”»
//      - IngresÃ³ vehÃ­culo 65. [43, 65] ğŸ”º
//
// REQUISITOS:
//  ğŸŸ¢ La funciÃ³n debe retornar la QUEUE resultante de procesar los movimientos.
//  ğŸŸ¢ Si la funciÃ³n intenta retirar un vehÃ­culo cuando la Queue se encuentra vacÃ­a,
//    debe retornar false
//  ğŸŸ¢ ATENCIÃ“N! La QUEUE que retorna la funciÃ³n debe ser una instancia de la clase QUEUE.

function henryParking(arr) {
  // Tu cÃ³digo aquÃ­:

  let cola = new Queue();
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== 'string') cola.enqueue(arr[i]);
    if (typeof arr[i] === 'OUT') {
      if (cola.size() === 0) return false;
      cola.dequeue();
    }
  }
  return cola;
}


// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
  henryParking
};
// 2ï¸âƒ£ ***** EJERCICIO 2 ***** - calcularIndice() 2ï¸âƒ£
// En este ejercicio, debemos implementar la funciÃ³n calcularIndice, la debe retornar
// un valor numÃ©rico que es parte de una secuencia de nÃºmeros que representa los Ã­ndices
// de precios que se aplicarÃ¡n en Henry Market en cada aÃ±o de actividad.
// La funciÃ³n recibirÃ¡ por parÃ¡metro el aÃ±o de actividad del supermercado (valor nÃºmÃ©rico 0 o mayor),
// y calcularÃ¡ el Ã­ndice en base a la siguiente secuencia:
//
// - Para el aÃ±o 0 (n=0) de actividad, el Ã­ndice es de 15
// - Para el aÃ±o 1 (n=1) de actividad, el Ã­ndice es 25
// - A partir del aÃ±o 2, el Ã­ndice se calcula con la fÃ³rmula f(n-1)+f(n-2)
//
// EJEMPLOS:
// - calcularIndice(0) => 15
// - caluclarIndice(1) => 25
// - calcularIndice(2) => calcularIndice(2-1) + calcularIndice(2-2) => 40
// - calcularIndice(3) => calcularIndice(3-1) + calcularIndice(3-2) => 65
//
// REQUISITOS:
//  ğŸŸ¢ La funciÃ³n debe obtener el Ã­ndice hallando de forma recursiva el valor correspondiente a n dentro de la secuencia.
//  ğŸŸ¢ La funciÃ³n debe retornar el valor numÃ©rico correspondiente a n dentro de la secuencia.
//  ğŸŸ¢ Si el valor de n recibido por parÃ¡metro es menor a 0, debe retornar false.

const calcularIndice = (n) => {
  // Tu cÃ³digo aquÃ­:
  if (n < 0) return false;
  if (n === 0) return 15;
  if (n === 1) return 25;
  return calcularIndice(n - 1) + calcularIndice(n - 2);
}


// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
  calcularIndice
};

const { Stack } = require("../DS");
// âš ï¸ NO MODIFICAR NADA POR ENCIMA DE ESTA LÃNEA âš ï¸

// 3ï¸âƒ£ ***** EJERCICIO 3 ***** - apilarCajas() 3ï¸âƒ£
// Se debe implementar la funciÃ³n apilarCajas, la cual ayudarÃ¡ a los encargados de depÃ³sito de
// Henry Market a armar pilas de cajas de productos de forma tal que no supere el peso mÃ¡ximo permitido
// y evitar asÃ­ que se daÃ±en los productos.
// La funciÃ³n recibirÃ¡ un array que representarÃ¡ las cajas que se desean apilar, con el nombre del producto
// y el peso total de cada caja, y deberÃ¡ crear y retornar un STACK con LOS NOMBRES de productos que vaya apilando,
// sin superar el peso mÃ¡ximo permitido.
// En caso de que los productos superen dicho peso mÃ¡ximo, deberÃ¡ retornar el string "No se puede crear la pila"
// Si el array recibido no contiene cajas, debe retornar el string "Error".

// El array recibido tendrÃ¡, por ejemplo, la siguiente forma:
//
// [
//  {nombre: arroz, peso: 10},
//  {nombre: fideos, peso: 15},
//  {nombre: cafe, peso: 5},
//  {nombre: arroz, peso: 10},
//  {nombre: azucar, peso: 20}
// ]
//
// TIPs:
//  - El array recibido es una ARRAY DE OBJETOS
//  - El array puede contener productos repetidos
//
//                     ********* El peso mÃ¡ximo permitido para cada STACK es de 50 kg! ***********
//
// EJEMPLOS:
//  - apilarCajas( [{nombre: arroz, peso: 10},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => Stack [arroz, fideos, cafe]
//                  * El peso total (30), no supera el mÃ¡ximo (50)
//
//  - apilarCajas( [{nombre: leche, peso: 30},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => Stack [leche, fideos, cafe]
//                  * El peso total (50), no supera el mÃ¡ximo (50)
//
//  - apilarCajas( [{nombre: leche, peso: 30},
//                  {nombre: fideos, peso: 15},
//                  {nombre: fideos, peso: 15},
//                  {nombre: cafe, peso: 5}] ) => "No se puede crear la pila"
//                  * El peso total (65), excede el peso mÃ¡ximo permitido (50)
//
//  - apilarCajas( [] ) => "Error"
//
// REQUISITOS:
//  ğŸŸ¢ La funciÃ³n debe crear y retornar el Stack creado con las cajas de productos recibidas en el array
//  ğŸŸ¢ El Stack que retorna debe ser una instancia de la clase Stack
//  ğŸŸ¢ En caso de exceder el peso mÃ¡ximo permitido, debe retornar en string "No se puede crear la pila"
//  ğŸŸ¢ En caso de recibir un array vacÃ­o, debe retornar el string "Error"
//
// ATENCIÃ“N! Las respuestas en strings son case sensitive!
//

function apilarCajas(arr) {
  // Tu cÃ³digo aquÃ­
  if (arr.length === 0) return 'Error';
  let pila = new Stack();
  let pesoTotal = 0;
  arr.forEach(objeto => {
    pesoTotal += objeto.peso;
    pila.push(objeto.nombre);
  });
  if (pesoTotal > 50) return 'No se puede crear la pila';
    return pila;
}
// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
    apilarCajas
};
// 4ï¸âƒ£ ***** EJERCICIO 4 ***** - devuelveMayores() 4ï¸âƒ£

// Implementar la funciÃ³n devuelveMayores, que recibe por parÃ¡metro una LinkedList con precios
// de productos de una determinada gÃ³ndola de Henry Market, y un precio mÃ¡ximo a evaluar.
// La funciÃ³n deberÃ¡ recorrer la LinkedList recibida y retornar la CANTIDAD DE PRECIOS QUE SUPEREN
// el valor de precio mÃ¡ximo que se desea evaluar.
// En caso de que ningÃºn precio supere dicho valor, debe retornar en string "Sin precios"

//  EJEMPLOS:
//
//  listaPrecios1 = 5 => 10 => 8 => 7 => 14 => 20
//  devuelveMayores(listaPrecios1, 10) => 2
//  (2 precios (14 y 20) superan el valor a evaluar (10))
//
//  listaPrecios2 = 99 => 100 => 81 => 74 => 14 => 22
//  devuelveMayores(listaPrecios2, 50) => 4
//  (4 precios (99, 100, 81 y 74) superan el valor a evaluar (50))
//
//  listaPrecios3 = 99 => 80 => 81 => 75 => 15 => 21
//  devuelveMayores(listaPrecios3, 100) => "Sin precios"
//  (NingÃºn precio de la lista supera el valor a evaluar (100))
//
//  REQUISITOS:
//    ğŸŸ¢ La funciÃ³n debe retornar un valor numÃ©rico, que representa la CANTIDAD DE PRECIOS que superen
//      el valor a evaluar.
//    ğŸŸ¢ En caso de que ningÃºn precio supere dicho valor, debe retornar el string "Sin precios"
//
//  ATENCIÃ“N! Las respuestas en strings son case sensitive!

function devuelveMayores(lista, valor) {
  // Tu cÃ³digo aquÃ­:
  let nodoActual = lista.head;
  //console.log(nodoActual);
  let cantidad = 0;
  while (nodoActual) {
    if (nodoActual.value > valor) cantidad++;
  }
    nodoActual = nodoActual.next;
  }
  if (cantidad === 0) return 'Sin precios';
  return cantidad;
}

// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
  devuelveMayores
};
// 5ï¸âƒ£ ***** EJERCICIO 5 ***** - cobrarClientes 5ï¸âƒ£

// Implementar la funciÃ³n cobrarClientes, que recibirÃ¡ una
// Queue (fila) de clientes que esperan para realizar el pago
// de sus compras del supermercado.
//
// Cada cliente dentro de la fila estarÃ¡ como objeto, y tendrÃ¡
// la siguiente estructura:
//
// {
//   nombre: "Jorge",
//   dinero: 1500,
//   precioProductos: 1200
// }
//
// - nombre: Nombre del cliente
// - dinero: Dinero disponible que tiene el cliente
// - precioProductos: Suma de los productos que desea comprar
//
// La funciÃ³n debe evaluar si el primer cliente de la fila poseee dinero suficiente
// para abonar los productos que desea comprar. En caso de ser asÃ­, debe remover
// al cliente de la fila.
// En caso de presentarse un cliente que no posee dinero suficiente, debe dejar de
// evaluar los clientes de la fila, y retornar un array con los NOMBRES de los clientes
// que fueron correctamente retirados de la fila.
//
// EJEMPLO:
//
// clientes=[
//  {
//   nombre: "Jorge",
//   dinero: 1500,
//   precioProductos: 1200
//  },
//  {
//   nombre: "Mateo",
//   dinero: 2000,
//   precioProductos: 1900
//  },
//  {
//   nombre: "Mora",
//   dinero: 5000,
//   precioProductos: 5500
//  },
//]
//
// cobrarClientes(clientes) => ["Jorge","Mateo"]
//
// âš ï¸ ATENCIÃ“N âš ï¸
// Recuerden que los "clientes" recibidos por parÃ¡metro se encuentran
// en una Queue! Por lo cual tendremos que utilizar los mÃ©todos que
// tenemos implementados para esta clase.
//
// CONSIGNAS:
//  ğŸŸ¢ Cuando termine de evaluar clientes, la funciÃ³n debe retornar un array con los nombres de los clientes que
//    han abonado correctamente.
//  ğŸŸ¢ En caso de quedarse sin clientes en la fila, la funciÃ³n debe retornar false.

function cobrarClientes(clientes) {
  // Tu cÃ³digo aquÃ­:
  let retirados = [];
  while (clientes.array[0].dinero >= clientes.array[0].precioProductos) {
    retirados.push(clientes.array[0].nombre);
    clientes.dequeue();
    if (clientes.size() === 0) return false;
  }
  return retirados;
}

// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
  cobrarClientes
};
const { BinarySearchTree } = require("../DS");
// âš ï¸ NO MODIFICAR NADA POR ENCIMA DE ESTA LÃNEA âš ï¸

// 6ï¸âƒ£ ***** EJERCICIO 6 ***** - agregarProductos 6ï¸âƒ£
// Implementar la funciÃ³n agregarProductos(producto) al prototipo de BinarySearchTree, que nos servirÃ¡ para
// agregar LOS NOMBRES de los productos en una gÃ³ndola de supermercado en base a las comparacionesde sus precios,
// siguiendo la siguiente tabla:
//
//    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
//    â”‚Productosâ”‚ Preciosâ”‚
//    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
//    â”‚  Leche  â”‚  100   â”‚
//    â”‚  Queso  â”‚  150   â”‚
//    â”‚   Pan   â”‚   50   â”‚
//    â”‚ Frutas  â”‚  110   â”‚
//    â”‚  Arroz  â”‚   40   â”‚
//    â”‚  Jugo   â”‚   80   â”‚
//    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
//  EJEMPLO:
//
//  Si partimos del Ã¡rbol inicial llamado "arbolDeProductos" con un solo nodo:
//
//                                              Leche
//                                              /    \
//
//    arbolDeProductos.agregarProductos(Queso)
//
//                                              Leche
//                                              /    \
//                                                   Queso
//
// El producto "Queso" se insertÃ³ a la derecha, ya que su precio (150), es mayor que el precio Leche (100).
//
//    arbolDeProductos.agregarProductos(Pan)
//
//                                             Leche
//                                             /    \
//                                          Pan      Queso
//
// El producto "Pan" se insertÃ³ a la izquierda, ya que su precio (50), es menor que el precio Leche (100).
//
//    arbolDeProductos.agregarProductos(Frutas)
//
//                                             Leche
//                                            /     \
//                                         Pan       Queso
//                                                  /
//                                               Frutas
//
// El producto "Frutas" en la posiciÃ³n correspondiente, ya que su precio (110), supera al de Leche (100) y
// es menor que precio de Queso (150).
//
// CONSIGNAS:
//  ğŸŸ¢ En caso de querer insertar un producto que ya se encuentra en el Ã¡rbol, debe retornar
//    el string "Ya existe el producto".
//  ğŸŸ¢ En caso de querer insertar un producto que no se encuentra en la tabla de precios, debe retornar
//    el string "Producto inexistente".
//  ğŸŸ¢ El mÃ©todo debe insertar el producto en la posiciÃ³n correspondiente, basando su ubicaciÃ³n en el
//    precio del producto. (Ver ejemplos)
//  ğŸŸ¢ En caso de insertar el producto correctamente, debe retornar el nuevo nodo que ha sido insertado.
//
//
// IMPORTANTE! La lista de productos se encuentra en el objeto productos a continuaciÃ³n:
//âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸

//âš ï¸ NO MODIFICAR NADA POR ENCIMA DE ESTA LÃNEA âš ï¸

BinarySearchTree.prototype.agregarProductos = function (nombreProducto, productos) {
  // Tu cÃ³digo aquÃ­:
  if (!productos.hasOwnProperty(nombreProducto)) return 'Producto inexistente';
  let vuelta;
  let temporal = this.value;
  if (nombreProducto === temporal) return 'Ya existe el producto';
  if (productos[nombreProducto] < productos[temporal]) {
    if (this.left === null) {
      var newTree = new BinarySearchTree(nombreProducto);
      this.left = newTree;
      return this.left;
    } else {
      return this.left.agregarProductos(nombreProducto, productos);
    }
  } else {
    if (this.right === null) {
      var newTree = new BinarySearchTree(nombreProducto);
      this.right = newTree;
      return this.right;
    } else {
      return this.right.agregarProductos(nombreProducto, productos);
    }
  }
};

// âš ï¸ NO MODIFICAR NADA POR DEBAJO DE ESTA LÃNEA âš ï¸
module.exports = {
    BinarySearchTree
};
